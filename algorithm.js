// Generated by LiveScript 1.2.0
var gensym, BNode, GNode, bfs, dist2, dist, unitDiskGraph, graphLinks, index, intersect, tracer, cabs, hTracer;
gensym = 0;
BNode = (function(){
  BNode.displayName = 'BNode';
  var prototype = BNode.prototype, constructor = BNode;
  function BNode(x, y){
    this.x = x;
    this.y = y;
    this.id = gensym++;
  }
  return BNode;
}());
GNode = (function(){
  GNode.displayName = 'GNode';
  var prototype = GNode.prototype, constructor = GNode;
  function GNode(node){
    this.node = node;
    this.id = gensym++;
    this.children = [];
  }
  return GNode;
}());
bfs = function(start, neighborsOf){
  var root, seen, ref$, links, queue, depth, tnode, i$, len$, neighbor, tneighbor;
  root = new GNode(start);
  seen = (ref$ = {}, ref$[start.id] = true, ref$);
  links = [];
  queue = [root];
  depth = 0;
  while ((tnode = queue.shift()) != null) {
    links[tnode.node] = [];
    for (i$ = 0, len$ = (ref$ = neighborsOf(tnode.node)).length; i$ < len$; ++i$) {
      neighbor = ref$[i$];
      if (seen[neighbor.id] == null) {
        tneighbor = new GNode(neighbor);
        queue.push(tneighbor);
        tnode.children.push(tneighbor);
        links.push({
          source: tnode.node,
          target: neighbor,
          depth: depth
        });
        seen[neighbor.id] = true;
      }
    }
    depth++;
  }
  return [root, seen, links, depth];
};
dist2 = function(a, b){
  return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
};
dist = function(a, b){
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
};
unitDiskGraph = function(unit, nodes){
  var unit2, neighbors, res$, i$, len$, n, i, j$, to$, j, m;
  unit2 = unit * unit;
  res$ = {};
  for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
    n = nodes[i$];
    res$[n.id] = [];
  }
  neighbors = res$;
  for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
    i = i$;
    n = nodes[i$];
    for (j$ = i + 1, to$ = nodes.length; j$ < to$; ++j$) {
      j = j$;
      m = nodes[j];
      if (dist2(n, m) < unit2) {
        neighbors[n.id].push(m);
        neighbors[m.id].push(n);
      }
    }
  }
  return neighbors;
};
graphLinks = function(graph, nodes){
  var seen, links, i$, len$, i, n, j$, ref$, len1$, m;
  seen = {};
  links = [];
  for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
    i = i$;
    n = nodes[i$];
    for (j$ = 0, len1$ = (ref$ = graph[n.id]).length; j$ < len1$; ++j$) {
      m = ref$[j$];
      if (!seen[m.id + "" + n.id]) {
        seen[m.id + "" + n.id] = true;
        links.push({
          source: n,
          target: m
        });
      }
    }
  }
  return links;
};
index = function(list, fn){
  var i, i$, len$, it;
  i = {};
  for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
    it = list[i$];
    i[fn(it)] = it;
  }
  return i;
};
intersect = function(a, b){
  var i, k;
  i = [];
  for (k in a) {
    if (b[k]) {
      i.push(k);
    }
  }
  return i;
};
tracer = ['Level', 'Independent Set', 'Cover', 'Cover → Set Color', 'Cover → Set Schedule', 'Uninformed', 'Set → Uninformed Color', 'Set → Uninformed Schedule'];
cabs = function(graph, gcr, gct, btree, set){
  var informed, level, schedule, trace, res$, i$, ref$, len$, thing, ref1$, i, uci, ui, node, inter, j$, len1$, n, subs1, subs, subtrace, wi, subs2;
  informed = {};
  level = [btree];
  schedule = [];
  res$ = [];
  for (i$ = 0, len$ = (ref$ = tracer).length; i$ < len$; ++i$) {
    thing = ref$[i$];
    res$.push((ref1$ = [], ref1$.name = thing, ref1$));
  }
  trace = res$;
  i = 0;
  while (level.length > 0) {
    trace[0].push(i);
    i++;
    uci = {};
    ui = level.map(fn$).filter(fn1$);
    for (i$ = 0, len$ = ui.length; i$ < len$; ++i$) {
      node = ui[i$];
      inter = intersect(uci, index(graph[node.id], fn2$));
      if (inter.length === 0) {
        for (j$ = 0, len1$ = (ref$ = graph[node.id]).length; j$ < len1$; ++j$) {
          n = ref$[j$];
          if (informed[n.id]) {
            uci[n.id] = n;
            break;
          }
        }
      }
    }
    trace[1].push(ui);
    uci = Object.keys(uci).map(fn3$);
    trace[2].push(uci);
    ref$ = subs1 = subCabs(graph, ui, true, uci, gcr), subs = ref$.subs, subtrace = ref$.subtrace;
    subs = subs.filter(fn4$);
    trace[3].push(subtrace);
    trace[4].push(subs);
    if (subs.length > 0) {
      schedule.push.apply(schedule, subs);
    }
    wi = [];
    for (i$ = 0, len$ = ui.length; i$ < len$; ++i$) {
      node = ui[i$];
      for (j$ = 0, len1$ = (ref$ = graph[node.id]).length; j$ < len1$; ++j$) {
        n = ref$[j$];
        if (!informed[n.id]) {
          wi.push(n);
        }
      }
    }
    trace[5].push(wi);
    ref$ = subs2 = subCabs(graph, ui, false, wi, gct), subs = ref$.subs, subtrace = ref$.subtrace;
    subs = subs.filter(fn5$);
    trace[6].push(subtrace);
    trace[7].push(subs);
    if (subs.length > 0) {
      schedule.push.apply(schedule, subs);
    }
    for (i$ = 0, len$ = (ref$ = wi.concat(ui)).length; i$ < len$; ++i$) {
      node = ref$[i$];
      informed[node.id] = true;
    }
    level = [].concat.apply([], level.map(fn6$));
  }
  return {
    trace: trace,
    schedule: schedule
  };
  function fn$(it){
    return it.node;
  }
  function fn1$(it){
    return set[it.id];
  }
  function fn2$(it){
    return it.id;
  }
  function fn3$(it){
    return uci[it];
  }
  function fn4$(it){
    return it.length > 0;
  }
  function fn5$(it){
    return it.length > 0;
  }
  function fn6$(it){
    return it.children;
  }
};
function filterGraph(graph, vertices){
  var v, filtered, n, nei;
  v = index(vertices, function(it){
    return it.id;
  });
  filtered = {};
  for (n in graph) {
    nei = graph[n];
    if (v[n]) {
      filtered[n] = nei.filter(fn$);
    }
  }
  return filtered;
  function fn$(it){
    return v[it.id] != null;
  }
}
function orderLeastDegree(graph){
  var order, n, nei;
  order = [];
  for (n in graph) {
    nei = graph[n];
    order.push([n, nei]);
  }
  return order.sort(function(a, b){
    return a[1].length - b[1].length;
  });
}
function coloring(graph){
  var max, col, i$, ref$, len$, ref1$, n, nei, neiCol, j$, len1$, nn, that, i;
  max = 0;
  col = {};
  for (i$ = 0, len$ = (ref$ = orderLeastDegree(graph)).length; i$ < len$; ++i$) {
    ref1$ = ref$[i$], n = ref1$[0], nei = ref1$[1];
    neiCol = {};
    for (j$ = 0, len1$ = nei.length; j$ < len1$; ++j$) {
      nn = nei[j$];
      if ((that = col[nn.id]) != null) {
        neiCol[that] = true;
      }
    }
    i = 0;
    while (neiCol[i]) {
      i++;
    }
    col[n] = i;
    max = max > i ? max : i;
  }
  return [col, max + 1];
}
function subCabs(graph, p, isReceive, q, gc){
  var subtrace, qi, fgraph, ref$, col, colors, s, res$, i$, i, len$, u, j$, len1$, n, subs;
  subtrace = {};
  qi = index(q, function(it){
    return it.id;
  });
  fgraph = filterGraph(gc, p);
  subtrace.p = p;
  subtrace.fgraph = fgraph;
  subtrace.links = graphLinks(fgraph, p);
  ref$ = coloring(fgraph), col = ref$[0], colors = ref$[1];
  subtrace.col = col;
  res$ = [];
  for (i$ = 0; i$ < colors; ++i$) {
    i = i$;
    res$.push({});
  }
  s = res$;
  if (q.length === 0 && !isReceive) {
    return {
      subs: [],
      subtrace: subtrace
    };
  }
  for (i$ = 0, len$ = p.length; i$ < len$; ++i$) {
    u = p[i$];
    if (isReceive) {
      for (j$ = 0, len1$ = (ref$ = graph[u.id]).length; j$ < len1$; ++j$) {
        n = ref$[j$];
        if (qi[n.id]) {
          s[col[u.id]][n.id] = n;
          break;
        }
      }
    } else {
      s[col[u.id]][u.id] = u;
    }
  }
  subs = s.map(function(set){
    return Object.keys(set).map(function(it){
      return set[it];
    });
  });
  return {
    subs: subs,
    subtrace: subtrace
  };
}
function toSet(list){
  var s, i$, x$, len$;
  s = {};
  for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
    x$ = list[i$];
    s[x$.id] = x$;
  }
  return s;
}
function toList(set){
  return Object.keys(set).map(function(it){
    return set[it];
  });
}
function setMinus(a, b){
  var s, k, v;
  s = {};
  for (k in a) {
    v = a[k];
    if (b[k] == null) {
      s[k] = v;
    }
  }
  return s;
}
function setSize(it){
  var s, k;
  s = 0;
  for (k in it) {
    s++;
  }
  return s;
}
function byFn(fn){
  return function(a, b){
    var fna, fnb;
    fna = fn(a);
    fnb = fn(b);
    if (fna > fnb) {
      return 1;
    } else if (fna < fnb) {
      return -1;
    } else {
      return 0;
    }
  };
}
hTracer = ['Active', 'Order', 'Schedule'];
function hcabs(graph, r, alpha, beta, s, nodes){
  var inf, ref$, inflen, active, time, schedule, trace, res$, i$, len$, thing, ref1$, q, k, n, ss, t, u, nInf, nuQ, v, vInf, w, inQ;
  inf = (ref$ = {}, ref$[s.id] = s, ref$);
  inflen = 1;
  active = (ref$ = {}, ref$[s.id] = s, ref$);
  time = 0;
  schedule = [];
  res$ = [];
  for (i$ = 0, len$ = (ref$ = hTracer).length; i$ < len$; ++i$) {
    thing = ref$[i$];
    res$.push((ref1$ = [], ref1$.name = thing, ref1$));
  }
  trace = res$;
  while (inflen < nodes.length) {
    q = [];
    for (k in active) {
      n = active[k];
      q.push(n);
    }
    trace[0].push(toList(active));
    ss = {};
    t = [];
    while (q.length > 0) {
      u = q.sort(byFn(fn$)).shift();
      delete active[u.id];
      nInf = setMinus(toSet(graph[u.id]), inf);
      if (setSize(nInf) > 0) {
        t.push({
          nInf: toList(nInf),
          u: u
        });
        nuQ = [];
        adder: for (i$ = 0, len$ = q.length; i$ < len$; ++i$) {
          v = q[i$];
          vInf = setMinus(toSet(graph[v.id]), inf);
          for (k in vInf) {
            w = vInf[k];
            if (!(dist(u, w) <= alpha * r)) {
              nuQ.push(v);
              continue adder;
            }
          }
        }
        q = nuQ;
        nuQ = [];
        inQ = {};
        for (k in nInf) {
          v = nInf[k];
          for (i$ = 0, len$ = q.length; i$ < len$; ++i$) {
            w = q[i$];
            if (!(inQ[w.id] || dist(w, v) <= alpha * r)) {
              inQ[w.id] = true;
              nuQ.push(w);
            }
          }
        }
        q = nuQ;
        nuQ = [];
        for (i$ = 0, len$ = q.length; i$ < len$; ++i$) {
          v = q[i$];
          if (!(dist(u, v) <= beta * r)) {
            nuQ.push(v);
          }
        }
        q = nuQ;
        ss[u.id] = u;
        for (k in nInf) {
          w = nInf[k];
          inf[w.id] = w;
          inflen++;
          active[w.id] = w;
        }
      }
    }
    trace[1].push(t);
    trace[2].push(toList(ss));
    schedule[time] = Object.keys(ss).map(fn1$);
    time++;
  }
  return [trace, schedule];
  function fn$(it){
    return setSize(setMinus(toSet(graph[it.id]), inf));
  }
  function fn1$(it){
    return ss[it];
  }
}